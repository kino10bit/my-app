# ã‚¢ã‚»ãƒƒãƒˆç®¡ç†è¨­è¨ˆæ›¸

## æ¦‚è¦
Appcadiaã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ãŠã‘ã‚‹ç”»åƒã€éŸ³å£°ã€ãƒ•ã‚©ãƒ³ãƒˆã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã©å…¨ã‚¢ã‚»ãƒƒãƒˆã®ç®¡ç†æˆ¦ç•¥ã€‚åŠ¹ç‡çš„ãªé…ä¿¡ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã€æœ€é©åŒ–ã‚’é€šã˜ã¦ã€é«˜å“è³ªãªãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã¨æœ€é©ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’å®Ÿç¾ã™ã‚‹ã€‚

## å®Ÿè£…ã•ã‚ŒãŸ ã‚¢ã‚»ãƒƒãƒˆç®¡ç†æˆ¦ç•¥

### 1. é™çš„ã‚¢ã‚»ãƒƒãƒˆç®¡ç†ï¼ˆç¾åœ¨ã®å®Ÿè£…ï¼‰
```typescript
// src/utils/AssetManager.ts - å®Ÿéš›ã®å®Ÿè£…
export class AssetManager {
  private static instance: AssetManager;
  
  // é™çš„ãªã‚¢ã‚»ãƒƒãƒˆå®šç¾©ï¼ˆReact Native require()åˆ¶ç´„å¯¾å¿œï¼‰
  private static readonly TRAINER_IMAGES = {
    // å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«åãƒãƒƒãƒ”ãƒ³ã‚°
    'akari': require('../../assets/images/trainers/akari.png'),
    'isuzu': require('../../assets/images/trainers/isuzu.png'),
    'kana': require('../../assets/images/trainers/kana.png'),
    'mika': require('../../assets/images/trainers/mika.png'),
    'rin': require('../../assets/images/trainers/rin.png'),
    
    // æ—§ãƒ‡ãƒ¼ã‚¿ã¨ã®äº’æ›æ€§ãƒãƒƒãƒ”ãƒ³ã‚°
    'ena': require('../../assets/images/trainers/akari.png'),
    'calm': require('../../assets/images/trainers/isuzu.png'),
    'shinji': require('../../assets/images/trainers/isuzu.png'),
    'takumi': require('../../assets/images/trainers/kana.png'),
    'miyuki': require('../../assets/images/trainers/mika.png'),
    'daiki': require('../../assets/images/trainers/rin.png')
  } as const;
  
  private static readonly TRAINER_AUDIO = {
    // éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆåŒæ§˜ã®æ§‹æˆï¼‰
    'akari': require('../../assets/audio/trainers/akari.mp3'),
    'isuzu': require('../../assets/audio/trainers/isuzu.mp3'),
    // ... ä»–ã®ãƒãƒƒãƒ”ãƒ³ã‚°
  } as const;
  
  // å‹•çš„ã‚¢ã‚»ãƒƒãƒˆï¼ˆã‚ªãƒ³ãƒ‡ãƒãƒ³ãƒ‰é…ä¿¡ï¼‰
  dynamic: {
    trainer_assets: {
      description: 'ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼é–¢é€£ã‚¢ã‚»ãƒƒãƒˆ',
      location: 'cdn',
      caching: 'long_term',
      examples: ['trainer_avatars', 'voice_clips', 'celebration_animations']
    },
    seasonal_content: {
      description: 'å­£ç¯€é™å®šã‚³ãƒ³ãƒ†ãƒ³ãƒ„',
      location: 'cdn',
      caching: 'temporary',
      examples: ['holiday_themes', 'seasonal_sounds', 'event_graphics']
    },
    user_generated: {
      description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ç”Ÿæˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„',
      location: 'local_storage',
      caching: 'user_controlled',
      examples: ['custom_goal_icons', 'user_recordings']
    }
  }
} as const;
```

### 2. å®Ÿéš›ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 
```
assets/
â”œâ”€â”€ images/
â”‚   â”œâ”€â”€ adaptive-icon.png          # ã‚¢ãƒ—ãƒªã‚¢ã‚¤ã‚³ãƒ³
â”‚   â”œâ”€â”€ favicon.png
â”‚   â”œâ”€â”€ icon.png
â”‚   â”œâ”€â”€ splash-icon.png
â”‚   â”œâ”€â”€ react-logo.png             # React Nativeãƒ­ã‚´
â”‚   â”œâ”€â”€ react-logo@2x.png
â”‚   â”œâ”€â”€ react-logo@3x.png
â”‚   â”œâ”€â”€ partial-react-logo.png
â”‚   â””â”€â”€ trainers/                  # ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ç”»åƒï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚       â”œâ”€â”€ README.md              # ãƒ•ã‚¡ã‚¤ãƒ«ä»•æ§˜æ›¸
â”‚       â”œâ”€â”€ HOW_TO_ADD_FILES.md    # è¿½åŠ æ–¹æ³•
â”‚       â”œâ”€â”€ akari.png              # ã‚ã‹ã‚Šï¼ˆã‚¨ãƒãƒ«ã‚®ãƒƒã‚·ãƒ¥ï¼‰
â”‚       â”œâ”€â”€ isuzu.png              # ã„ã™ãšï¼ˆç©ã‚„ã‹ï¼‰
â”‚       â”œâ”€â”€ kana.png               # ã‹ãªï¼ˆå³æ ¼ï¼‰
â”‚       â”œâ”€â”€ mika.png               # ã¿ã‹ï¼ˆå„ªã—ã„ï¼‰
â”‚       â”œâ”€â”€ rin.png                # ã‚Šã‚“ï¼ˆã‚„ã‚‹æ°—æº€ã€…ï¼‰
â”‚       â””â”€â”€ placeholder.md         # ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼èª¬æ˜
â”œâ”€â”€ audio/
â”‚   â””â”€â”€ trainers/                  # ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼éŸ³å£°ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚       â”œâ”€â”€ README.md
â”‚       â”œâ”€â”€ HOW_TO_ADD_FILES.md
â”‚       â”œâ”€â”€ akari.mp3              # ã‚ã‹ã‚Šã®éŸ³å£°
â”‚       â”œâ”€â”€ isuzu.mp3              # ã„ã™ãšã®éŸ³å£°
â”‚       â”œâ”€â”€ kana.mp3               # ã‹ãªã®éŸ³å£°
â”‚       â”œâ”€â”€ mika.mp3               # ã¿ã‹ã®éŸ³å£°
â”‚       â”œâ”€â”€ rin.mp3                # ã‚Šã‚“ã®éŸ³å£°
â”‚       â””â”€â”€ placeholder.md
â””â”€â”€ fonts/
    â””â”€â”€ SpaceMono-Regular.ttf      # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ³ãƒˆ
```

## ç”»åƒã‚¢ã‚»ãƒƒãƒˆç®¡ç†

### 1. ç”»åƒæœ€é©åŒ–æˆ¦ç•¥
```typescript
// services/ImageOptimizationService.ts
export class ImageOptimizationService {
  
  // ç”»åƒå½¢å¼ãƒ»ã‚µã‚¤ã‚ºæœ€é©åŒ–è¨­å®š
  static readonly OPTIMIZATION_CONFIG = {
    // ã‚¢ã‚¤ã‚³ãƒ³é¡
    icons: {
      format: 'svg',        // SVGå„ªå…ˆ
      fallback: 'png',      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      sizes: [24, 32, 48, 64],
      optimization: {
        svgo: true,         // SVGæœ€é©åŒ–
        pngquant: true      // PNGåœ§ç¸®
      }
    },
    
    // ã‚¤ãƒ©ã‚¹ãƒˆé¡
    illustrations: {
      format: 'png',
      quality: 85,
      sizes: {
        small: 300,   // @1x
        medium: 600,  // @2x  
        large: 900    // @3x
      },
      optimization: {
        tinypng: true,
        webp_support: true
      }
    },
    
    // ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ç”»åƒ
    trainers: {
      format: 'png',
      quality: 90,          // é«˜å“è³ªç¶­æŒ
      sizes: {
        thumbnail: 100,
        small: 200,
        medium: 400,
        large: 800
      },
      optimization: {
        progressive: true,
        webp_support: true
      }
    }
  };
  
  // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ç”»åƒé…ä¿¡
  static getOptimalImageSource(
    imageName: string, 
    category: keyof typeof OPTIMIZATION_CONFIG,
    screenDensity: number = PixelRatio.get()
  ): ImageSource {
    const config = this.OPTIMIZATION_CONFIG[category];
    
    // ç”»é¢å¯†åº¦ã«åŸºã¥ãæœ€é©ã‚µã‚¤ã‚ºé¸æŠ
    let targetSize: string;
    if (screenDensity >= 3) {
      targetSize = 'large';
    } else if (screenDensity >= 2) {
      targetSize = 'medium';
    } else {
      targetSize = 'small';
    }
    
    // WebPå¯¾å¿œãƒã‚§ãƒƒã‚¯
    const supportsWebP = this.checkWebPSupport();
    const extension = supportsWebP ? 'webp' : config.format;
    
    return {
      uri: `${CDN_BASE_URL}/${category}/${imageName}_${targetSize}.${extension}`,
      cache: 'force-cache',
      headers: {
        'Accept': supportsWebP ? 'image/webp,image/*' : 'image/*'
      }
    };
  }
  
  // ç”»åƒãƒ—ãƒªãƒ­ãƒ¼ãƒ‰
  static async preloadCriticalImages(): Promise<void> {
    const criticalImages = [
      // UIã‚¢ã‚¤ã‚³ãƒ³
      'home', 'goals', 'trainer', 'settings',
      
      // åŸºæœ¬ã‚¤ãƒ©ã‚¹ãƒˆ
      'welcome', 'goal-creation', 'celebration',
      
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ç”»åƒ
      'sakura_avatar', 'akira_avatar', 'midori_avatar'
    ];
    
    const preloadPromises = criticalImages.map(async (imageName) => {
      try {
        await FastImage.preload([{
          uri: this.getImageUri(imageName),
          priority: FastImage.priority.high
        }]);
      } catch (error) {
        console.warn(`Failed to preload image: ${imageName}`, error);
      }
    });
    
    await Promise.allSettled(preloadPromises);
  }
  
  // ç”»åƒã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†
  static configureCaching(): void {
    FastImage.setCacheLimit({
      memory: 64 * 1024 * 1024,    // 64MB ãƒ¡ãƒ¢ãƒªã‚­ãƒ£ãƒƒã‚·ãƒ¥
      disk: 256 * 1024 * 1024      // 256MB ãƒ‡ã‚£ã‚¹ã‚¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    });
    
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
    this.scheduleCache Cleanup();
  }
  
  private static scheduleCacheCleanup(): void {
    // é€±1å›ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    setInterval(async () => {
      try {
        await FastImage.clearDiskCache();
        await FastImage.clearMemoryCache();
        console.log('Image cache cleanup completed');
      } catch (error) {
        console.error('Cache cleanup failed:', error);
      }
    }, 7 * 24 * 60 * 60 * 1000); // 1é€±é–“
  }
}
```

### 2. ã‚¢ãƒ€ãƒ—ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆAndroidå¯¾å¿œï¼‰
```typescript
// utils/AdaptiveIconGenerator.ts
export class AdaptiveIconGenerator {
  
  // ã‚¢ãƒ€ãƒ—ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ã‚³ãƒ³ç”Ÿæˆè¨­å®š
  static readonly ADAPTIVE_ICON_CONFIG = {
    foreground: {
      size: 108,           // 108dp
      safeZone: 66,        // 66dp (ä¸­å¿ƒã‹ã‚‰33dp)
      format: 'png',
      backgroundColor: 'transparent'
    },
    background: {
      size: 108,           // 108dp
      format: 'png',
      colors: {
        primary: '#6750A4',
        gradient: ['#6750A4', '#8E7CC3']
      }
    },
    legacy: {
      size: 48,            // 48dp
      format: 'png',
      rounded: true
    }
  };
  
  // ã‚¢ãƒ€ãƒ—ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ã‚³ãƒ³ç”Ÿæˆ
  static async generateAdaptiveIcons(): Promise<AdaptiveIconSet> {
    const iconSet: AdaptiveIconSet = {
      foreground: await this.generateForeground(),
      background: await this.generateBackground(),
      legacy: await this.generateLegacyIcon(),
      monochrome: await this.generateMonochromeIcon() // Android 13+
    };
    
    return iconSet;
  }
  
  private static async generateForeground(): Promise<Canvas> {
    const canvas = this.createCanvas(108, 108);
    const ctx = canvas.getContext('2d');
    
    // é€æ˜èƒŒæ™¯
    ctx.clearRect(0, 0, 108, 108);
    
    // ã‚»ãƒ¼ãƒ•ã‚¾ãƒ¼ãƒ³å†…ã«ãƒ­ã‚´é…ç½®
    const logoSize = 66;
    const offset = (108 - logoSize) / 2;
    
    // ã‚¢ãƒ—ãƒªãƒ­ã‚´ã‚’ä¸­å¤®ã«æç”»
    await this.drawLogo(ctx, offset, offset, logoSize, logoSize);
    
    return canvas;
  }
  
  private static async generateBackground(): Promise<Canvas> {
    const canvas = this.createCanvas(108, 108);
    const ctx = canvas.getContext('2d');
    
    // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯
    const gradient = ctx.createLinearGradient(0, 0, 108, 108);
    gradient.addColorStop(0, '#6750A4');
    gradient.addColorStop(1, '#8E7CC3');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 108, 108);
    
    // è£…é£¾ãƒ‘ã‚¿ãƒ¼ãƒ³è¿½åŠ ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    await this.addBackgroundPattern(ctx);
    
    return canvas;
  }
  
  // ãƒ†ãƒ¼ãƒã‚¢ã‚¤ã‚³ãƒ³ï¼ˆAndroid 13+ Themed Iconsï¼‰
  private static async generateMonochromeIcon(): Promise<Canvas> {
    const canvas = this.createCanvas(108, 108);
    const ctx = canvas.getContext('2d');
    
    // ãƒ¢ãƒã‚¯ãƒ­ãƒ¼ãƒ ã‚¢ã‚¤ã‚³ãƒ³ã¯å˜è‰²ã§æç”»
    ctx.fillStyle = '#000000'; // ã‚·ã‚¹ãƒ†ãƒ ãŒè‰²ã‚’åˆ¶å¾¡
    
    // ã‚·ãƒ³ãƒ—ãƒ«ãªã‚·ãƒ«ã‚¨ãƒƒãƒˆç‰ˆãƒ­ã‚´ã‚’æç”»
    await this.drawMonochromeLogo(ctx, 21, 21, 66, 66);
    
    return canvas;
  }
}
```

## éŸ³å£°ã‚¢ã‚»ãƒƒãƒˆç®¡ç†

### 1. éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«æœ€é©åŒ–
```typescript
// services/AudioAssetService.ts
export class AudioAssetService {
  
  // éŸ³å£°å½¢å¼æœ€é©åŒ–è¨­å®š
  static readonly AUDIO_CONFIG = {
    system_sounds: {
      format: 'mp3',
      bitrate: 128,        // kbps
      sampleRate: 44100,   // Hz
      duration: {
        max: 2000          // 2ç§’ä»¥ä¸‹
      },
      compression: 'high'
    },
    
    trainer_voices: {
      format: 'mp3',
      bitrate: 192,        // é«˜å“è³ª
      sampleRate: 44100,
      duration: {
        min: 1000,         // 1ç§’ä»¥ä¸Š
        max: 10000         // 10ç§’ä»¥ä¸‹
      },
      compression: 'medium',
      normalization: true  // éŸ³é‡æ­£è¦åŒ–
    },
    
    ambient_sounds: {
      format: 'mp3',
      bitrate: 160,
      sampleRate: 44100,
      duration: {
        loop: true,        // ãƒ«ãƒ¼ãƒ—å¯¾å¿œ
        max: 60000         // 1åˆ†ä»¥ä¸‹
      },
      compression: 'medium'
    }
  };
  
  // éŸ³å£°ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ç®¡ç†
  static async preloadEssentialAudio(): Promise<void> {
    const essentialAudio = [
      // ã‚·ã‚¹ãƒ†ãƒ éŸ³
      'notification', 'success', 'error', 'button-tap',
      
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ã®åŸºæœ¬ãƒœã‚¤ã‚¹
      'sakura_welcome', 'sakura_encouragement', 'sakura_celebration'
    ];
    
    for (const audioName of essentialAudio) {
      try {
        const audioPath = this.getAudioPath(audioName);
        await Audio.Sound.createAsync({ uri: audioPath });
        console.log(`Preloaded audio: ${audioName}`);
      } catch (error) {
        console.warn(`Failed to preload audio: ${audioName}`, error);
      }
    }
  }
  
  // é©å¿œçš„å“è³ªé…ä¿¡
  static getOptimalAudioSource(
    audioName: string,
    category: keyof typeof AUDIO_CONFIG,
    networkQuality: 'high' | 'medium' | 'low' = 'medium'
  ): AudioSource {
    const config = this.AUDIO_CONFIG[category];
    
    // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å“è³ªã«åŸºã¥ãæœ€é©åŒ–
    let bitrate = config.bitrate;
    if (networkQuality === 'low') {
      bitrate = Math.floor(bitrate * 0.7); // 30%å‰Šæ¸›
    } else if (networkQuality === 'high') {
      bitrate = Math.floor(bitrate * 1.2); // 20%å‘ä¸Š
    }
    
    return {
      uri: `${CDN_BASE_URL}/audio/${category}/${audioName}_${bitrate}kbps.${config.format}`,
      shouldPlay: false,
      isLooping: config.duration?.loop || false
    };
  }
  
  // éŸ³å£°ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥
  static configureAudioCaching(): void {
    // é‡è¦ãªéŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®æ°¸ç¶šã‚­ãƒ£ãƒƒã‚·ãƒ¥
    const persistentCache = [
      'system_sounds',     // ã‚·ã‚¹ãƒ†ãƒ éŸ³ã¯å¸¸ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥
      'selected_trainer'   // é¸æŠä¸­ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ã®ãƒœã‚¤ã‚¹
    ];
    
    // ä¸€æ™‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆ7æ—¥é–“ï¼‰
    const temporaryCache = [
      'other_trainers',    // ãã®ä»–ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ãƒœã‚¤ã‚¹
      'ambient_sounds'     // ç’°å¢ƒéŸ³
    ];
    
    this.setupCachePolicy(persistentCache, 'permanent');
    this.setupCachePolicy(temporaryCache, '7days');
  }
  
  // éŸ³å£°å†ç”Ÿç®¡ç†
  static async playSound(
    soundName: string,
    category: string,
    options: AudioPlayOptions = {}
  ): Promise<Audio.Sound> {
    try {
      const audioSource = this.getOptimalAudioSource(soundName, category);
      const { sound } = await Audio.Sound.createAsync(audioSource, {
        shouldPlay: options.autoPlay ?? true,
        volume: options.volume ?? 1.0,
        rate: options.rate ?? 1.0,
        isLooping: options.loop ?? false
      });
      
      // å†ç”Ÿå®Œäº†å¾Œã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      sound.setOnPlaybackStatusUpdate((status) => {
        if (status.isLoaded && status.didJustFinish && !status.isLooping) {
          sound.unloadAsync();
        }
      });
      
      return sound;
    } catch (error) {
      console.error(`Failed to play sound: ${soundName}`, error);
      throw error;
    }
  }
}
```

### 2. ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼éŸ³å£°ç®¡ç†
```typescript
// services/TrainerVoiceManager.ts
export class TrainerVoiceManager {
  private voiceCache = new Map<string, Audio.Sound>();
  
  // éŸ³å£°ã‚«ãƒ†ã‚´ãƒªå®šç¾©
  static readonly VOICE_CATEGORIES = {
    welcome: {
      description: 'åˆå›é¸æŠæ™‚ã®æ­“è¿ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸',
      priority: 'high',
      preload: true
    },
    encouragement: {
      description: 'æ—¥å¸¸çš„ãªåŠ±ã¾ã—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸',
      priority: 'high',
      preload: true,
      variations: 5    // ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³æ•°
    },
    celebration: {
      description: 'ç›®æ¨™é”æˆæ™‚ã®ç¥ç¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸',
      priority: 'medium',
      preload: false,
      variations: 3
    },
    motivation: {
      description: 'ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³å‘ä¸Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸',
      priority: 'medium',
      preload: false,
      variations: 4
    },
    milestone: {
      description: 'ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³é”æˆæ™‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸',
      priority: 'low',
      preload: false,
      variations: 2
    }
  } as const;
  
  // ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼éŸ³å£°ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰
  async preloadTrainerVoices(trainerId: string): Promise<void> {
    const trainer = await this.getTrainerData(trainerId);
    
    for (const [category, config] of Object.entries(this.VOICE_CATEGORIES)) {
      if (config.preload) {
        await this.preloadVoiceCategory(trainerId, category, config);
      }
    }
    
    console.log(`Preloaded voices for trainer: ${trainer.name}`);
  }
  
  private async preloadVoiceCategory(
    trainerId: string, 
    category: string, 
    config: any
  ): Promise<void> {
    const variations = config.variations || 1;
    
    for (let i = 1; i <= variations; i++) {
      const voiceKey = `${trainerId}_${category}_${i}`;
      
      try {
        const audioSource = AudioAssetService.getOptimalAudioSource(
          voiceKey,
          'trainer_voices'
        );
        
        const { sound } = await Audio.Sound.createAsync(audioSource, {
          shouldPlay: false
        });
        
        this.voiceCache.set(voiceKey, sound);
      } catch (error) {
        console.warn(`Failed to preload voice: ${voiceKey}`, error);
      }
    }
  }
  
  // ãƒ©ãƒ³ãƒ€ãƒ éŸ³å£°é¸æŠãƒ»å†ç”Ÿ
  async playRandomVoice(
    trainerId: string,
    category: keyof typeof TrainerVoiceManager.VOICE_CATEGORIES
  ): Promise<void> {
    const config = TrainerVoiceManager.VOICE_CATEGORIES[category];
    const variations = config.variations || 1;
    const randomIndex = Math.floor(Math.random() * variations) + 1;
    
    const voiceKey = `${trainerId}_${category}_${randomIndex}`;
    
    try {
      let sound = this.voiceCache.get(voiceKey);
      
      if (!sound) {
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãªã„å ´åˆã¯å‹•çš„èª­ã¿è¾¼ã¿
        const audioSource = AudioAssetService.getOptimalAudioSource(
          voiceKey,
          'trainer_voices'
        );
        
        const result = await Audio.Sound.createAsync(audioSource);
        sound = result.sound;
      }
      
      await sound.replayAsync();
      
      // ä½¿ç”¨çµ±è¨ˆè¨˜éŒ²
      AnalyticsService.trackUserAction({
        type: 'trainer_voice_played',
        screen: 'various',
        elementId: category,
        metadata: {
          trainerId,
          voiceKey,
          category
        }
      });
      
    } catch (error) {
      console.error(`Failed to play trainer voice: ${voiceKey}`, error);
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆéŸ³å£°å†ç”Ÿ
      await this.playFallbackVoice(category);
    }
  }
  
  // éŸ³å£°ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  async cleanupVoiceCache(): Promise<void> {
    for (const [key, sound] of this.voiceCache) {
      try {
        await sound.unloadAsync();
      } catch (error) {
        console.warn(`Failed to unload sound: ${key}`, error);
      }
    }
    
    this.voiceCache.clear();
    console.log('Voice cache cleanup completed');
  }
  
  // ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼å¤‰æ›´æ™‚ã®éŸ³å£°åˆ‡ã‚Šæ›¿ãˆ
  async switchTrainerVoices(fromTrainerId: string, toTrainerId: string): Promise<void> {
    // å¤ã„ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ã®éŸ³å£°ã‚’ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰
    await this.unloadTrainerVoices(fromTrainerId);
    
    // æ–°ã—ã„ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ã®éŸ³å£°ã‚’ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰
    await this.preloadTrainerVoices(toTrainerId);
    
    // æ­“è¿ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å†ç”Ÿ
    await this.playRandomVoice(toTrainerId, 'welcome');
  }
}
```

## ãƒ•ã‚©ãƒ³ãƒˆç®¡ç†

### 1. ãƒ•ã‚©ãƒ³ãƒˆæœ€é©åŒ–æˆ¦ç•¥
```typescript
// services/FontManager.ts
export class FontManager {
  
  // ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š
  static readonly FONT_CONFIG = {
    primary: {
      family: 'NotoSansJP',
      weights: [300, 400, 500, 700],
      formats: ['otf', 'woff2'], // Webå¯¾å¿œå«ã‚€
      subsetting: true,          // ã‚µãƒ–ã‚»ãƒƒãƒˆåŒ–
      unicodeRange: 'U+3040-309F,U+30A0-30FF,U+4E00-9FAF', // ã²ã‚‰ãŒãªã€ã‚«ã‚¿ã‚«ãƒŠã€æ¼¢å­—
      fallback: 'system-ui, sans-serif'
    },
    
    icon: {
      family: 'MaterialIcons',
      weights: [400],
      formats: ['ttf'],
      subsetting: false,
      codepoints: this.getRequiredIconCodepoints()
    },
    
    monospace: {
      family: 'RobotoMono',
      weights: [400, 500],
      formats: ['otf'],
      subsetting: true,
      usage: 'debug_only' // é–‹ç™ºãƒ“ãƒ«ãƒ‰ã®ã¿
    }
  };
  
  // å¿…è¦ãªã‚¢ã‚¤ã‚³ãƒ³ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
  private static getRequiredIconCodepoints(): string[] {
    return [
      'e88a', // home
      'e8b6', // person  
      'e87c', // settings
      'e145', // check_circle
      'ef3a', // circle
      'e86f', // notifications
      'e5d2', // play_arrow
      'e034', // favorite
      'e8b8'  // star
    ];
  }
  
  // ãƒ•ã‚©ãƒ³ãƒˆãƒ—ãƒªãƒ­ãƒ¼ãƒ‰
  static async preloadFonts(): Promise<void> {
    const fontPromises = Object.entries(this.FONT_CONFIG).map(async ([name, config]) => {
      if (config.usage === 'debug_only' && !__DEV__) {
        return; // æœ¬ç•ªãƒ“ãƒ«ãƒ‰ã§ã¯ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ•ã‚©ãƒ³ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—
      }
      
      for (const weight of config.weights) {
        try {
          await Font.loadAsync({
            [`${config.family}-${weight}`]: {
              uri: this.getFontUri(config.family, weight, config.formats[0]),
              display: Font.FontDisplay.SWAP
            }
          });
        } catch (error) {
          console.warn(`Failed to load font: ${config.family}-${weight}`, error);
        }
      }
    });
    
    await Promise.allSettled(fontPromises);
  }
  
  // å‹•çš„ãƒ•ã‚©ãƒ³ãƒˆèª­ã¿è¾¼ã¿
  static async loadFontVariant(family: string, weight: number): Promise<boolean> {
    try {
      const config = this.FONT_CONFIG[family];
      if (!config) {
        throw new Error(`Unknown font family: ${family}`);
      }
      
      const fontKey = `${config.family}-${weight}`;
      
      if (Font.isLoaded(fontKey)) {
        return true; // æ—¢ã«èª­ã¿è¾¼ã¿æ¸ˆã¿
      }
      
      await Font.loadAsync({
        [fontKey]: {
          uri: this.getFontUri(config.family, weight, config.formats[0])
        }
      });
      
      return true;
    } catch (error) {
      console.error(`Failed to load font variant: ${family}-${weight}`, error);
      return false;
    }
  }
  
  // ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç®¡ç†
  static getFontFamily(requestedFont: string, weight: number = 400): string {
    const config = this.FONT_CONFIG[requestedFont];
    if (!config) {
      return 'system-ui'; // ã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    }
    
    const fontKey = `${config.family}-${weight}`;
    
    if (Font.isLoaded(fontKey)) {
      return fontKey;
    }
    
    // è¿‘ã„å¤ªã•ã®ãƒ•ã‚©ãƒ³ãƒˆã‚’æ¢ã™
    const availableWeights = config.weights.filter(w => 
      Font.isLoaded(`${config.family}-${w}`)
    );
    
    if (availableWeights.length > 0) {
      // æœ€ã‚‚è¿‘ã„å¤ªã•ã‚’é¸æŠ
      const closestWeight = availableWeights.reduce((prev, curr) => 
        Math.abs(curr - weight) < Math.abs(prev - weight) ? curr : prev
      );
      
      return `${config.family}-${closestWeight}`;
    }
    
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    return config.fallback || 'system-ui';
  }
}
```

## ã‚¢ã‚»ãƒƒãƒˆé…ä¿¡æœ€é©åŒ–

### 1. CDNçµ±åˆ
```typescript
// services/AssetDeliveryService.ts
export class AssetDeliveryService {
  private static readonly CDN_ENDPOINTS = {
    primary: 'https://cdn.appcadia.com',
    backup: 'https://backup-cdn.appcadia.com',
    regional: {
      jp: 'https://jp.cdn.appcadia.com',
      us: 'https://us.cdn.appcadia.com',
      eu: 'https://eu.cdn.appcadia.com'
    }
  };
  
  // æœ€é©ãªCDNã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆé¸æŠ
  static async selectOptimalCDN(): Promise<string> {
    const userLocation = await this.getUserLocation();
    
    // åœ°åŸŸãƒ™ãƒ¼ã‚¹ã®é¸æŠ
    if (userLocation.country === 'JP') {
      return this.CDN_ENDPOINTS.regional.jp;
    } else if (userLocation.continent === 'NA') {
      return this.CDN_ENDPOINTS.regional.us;
    } else if (userLocation.continent === 'EU') {
      return this.CDN_ENDPOINTS.regional.eu;
    }
    
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    return this.CDN_ENDPOINTS.primary;
  }
  
  // ã‚¢ã‚»ãƒƒãƒˆé…ä¿¡ç›£è¦–
  static async monitorAssetDelivery(): Promise<AssetDeliveryMetrics> {
    const metrics = {
      responseTime: new Map<string, number>(),
      hitRate: new Map<string, number>(),
      errorRate: new Map<string, number>()
    };
    
    // ä¸»è¦ã‚¢ã‚»ãƒƒãƒˆã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š
    const testAssets = [
      'icons/home.svg',
      'trainers/sakura/avatar.png',
      'audio/system/notification.mp3'
    ];
    
    for (const assetPath of testAssets) {
      const startTime = Date.now();
      
      try {
        const response = await fetch(`${this.CDN_ENDPOINTS.primary}/${assetPath}`, {
          method: 'HEAD'
        });
        
        const responseTime = Date.now() - startTime;
        metrics.responseTime.set(assetPath, responseTime);
        metrics.hitRate.set(assetPath, response.status === 200 ? 1 : 0);
        metrics.errorRate.set(assetPath, response.status >= 400 ? 1 : 0);
        
      } catch (error) {
        metrics.errorRate.set(assetPath, 1);
        console.warn(`Asset delivery test failed: ${assetPath}`, error);
      }
    }
    
    return metrics;
  }
  
  // ãƒ—ãƒ­ã‚°ãƒ¬ãƒƒã‚·ãƒ–ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  static async downloadAssetProgressive(
    assetUrl: string,
    onProgress?: (progress: number) => void
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      const downloadResumable = FileSystem.createDownloadResumable(
        assetUrl,
        `${FileSystem.documentDirectory}cache/${this.getAssetCacheKey(assetUrl)}`,
        {},
        (downloadProgress) => {
          const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;
          onProgress?.(progress);
        }
      );
      
      downloadResumable.downloadAsync()
        .then((result) => {
          if (result?.uri) {
            resolve(result.uri);
          } else {
            reject(new Error('Download failed'));
          }
        })
        .catch(reject);
    });
  }
}
```

## å®Ÿè£…æ¸ˆã¿æ©Ÿèƒ½ã¨ä»Šå¾Œã®æ‹¡å¼µ

### å®Ÿè£…æ¸ˆã¿æ©Ÿèƒ½ âœ…
- [x] åŸºæœ¬ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ç¢ºç«‹
- [x] ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ç”»åƒãƒ»éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«å®Ÿè£…
- [x] é™çš„ã‚¢ã‚»ãƒƒãƒˆç®¡ç†ï¼ˆAssetManagerï¼‰
- [x] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ï¼ˆè¤‡æ•°ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å¯¾å¿œï¼‰
- [x] äº’æ›æ€§ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆæ—§ãƒ‡ãƒ¼ã‚¿å¯¾å¿œï¼‰
- [x] ã‚¢ã‚»ãƒƒãƒˆå­˜åœ¨ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½
- [x] ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ãƒ»ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
- [x] React Native require()åˆ¶ç´„å¯¾å¿œ

### å®Ÿè£…ã•ã‚ŒãŸãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆ¦ç•¥
```typescript
// src/screens/SimpleTrainerSelection.tsx
const getTrainerImage = (trainer: TrainerModel) => {
  let imageKey;
  
  // 1. voicePrefixã‚’å„ªå…ˆä½¿ç”¨
  if (trainer.voicePrefix && trainer.voicePrefix.trim() !== '') {
    imageKey = trainer.voicePrefix;
  }
  // 2. avatarImageNameã‹ã‚‰æ‹¡å¼µå­ã‚’é™¤å»
  else if (trainer.avatarImageName && trainer.avatarImageName.trim() !== '') {
    imageKey = trainer.avatarImageName.replace('.png', '').replace('trainer_', '');
  }
  // 3. ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼åã‹ã‚‰ãƒ­ãƒ¼ãƒå­—ãƒãƒƒãƒ”ãƒ³ã‚°
  else {
    const nameMap = {
      'ã‚ã‹ã‚Š': 'akari', 'ã„ã™ãš': 'isuzu', 'ã‹ãª': 'kana',
      'ã¿ã‹': 'mika', 'ã‚Šã‚“': 'rin'
    };
    imageKey = nameMap[trainer.name] || trainer.name;
  }
  
  return assetManager.getTrainerImage(imageKey);
};
```

### ä»Šå¾Œã®æ‹¡å¼µè¨ˆç”»
- [ ] CDNçµ±åˆã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥
- [ ] ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ã‚¢ã‚»ãƒƒãƒˆé…ä¿¡
- [ ] ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ãƒ»é…å»¶èª­ã¿è¾¼ã¿å®Ÿè£…
- [ ] ã‚¢ã‚»ãƒƒãƒˆé…ä¿¡ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 
- [ ] å‹•çš„ã‚¢ã‚»ãƒƒãƒˆé…ä¿¡ã‚·ã‚¹ãƒ†ãƒ 
- [ ] A/Bãƒ†ã‚¹ãƒˆç”¨ã‚¢ã‚»ãƒƒãƒˆåˆ‡ã‚Šæ›¿ãˆ

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã¨ãƒ‡ãƒãƒƒã‚°

### 1. ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ–¹æ³•

#### ã‚¢ã‚»ãƒƒãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
```typescript
// AssetManager.tsã§ã®ãƒ­ã‚°ç¢ºèª
console.log('åˆ©ç”¨å¯èƒ½ãªç”»åƒã‚­ãƒ¼:', Object.keys(TRAINER_IMAGES));
console.log('åˆ©ç”¨å¯èƒ½ãªéŸ³å£°ã‚­ãƒ¼:', Object.keys(TRAINER_AUDIO));

// AssetHelper.tsã§ã®çŠ¶æ³ç¢ºèª
import { logAssetStatus, checkTrainerAssets } from '../utils/AssetHelper';
logAssetStatus();                    // å…¨ä½“çŠ¶æ³
checkTrainerAssets('trainerId');     // ç‰¹å®šãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼
```

#### ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼IDã¨ãƒ•ã‚¡ã‚¤ãƒ«åã®ä¸ä¸€è‡´
```typescript
// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒªã‚»ãƒƒãƒˆãŒå¿…è¦ãªå ´åˆ
import { resetDatabaseWithNewTrainers } from '../utils/AssetHelper';
await resetDatabaseWithNewTrainers();
```

#### JSONå¾ªç’°å‚ç…§ã‚¨ãƒ©ãƒ¼
```typescript
// WatermelonDBã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®‰å…¨ãªè¡¨ç¤º
const shortId = trainer.id ? trainer.id.slice(0, 8) : 'N/A';
console.log(`${trainer.name || 'Unknown'} (ID: ${shortId}...)`);
// JSON.stringify(trainer) ã¯ä½¿ç”¨ç¦æ­¢
```

### 2. ãƒ‡ãƒãƒƒã‚°æ”¯æ´æ©Ÿèƒ½
- **AssetHelper.logAssetStatus()**: å…¨ã‚¢ã‚»ãƒƒãƒˆçŠ¶æ³è¡¨ç¤º
- **AssetHelper.checkTrainerAssets(id)**: ç‰¹å®šãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ã®ã‚¢ã‚»ãƒƒãƒˆç¢ºèª
- **AssetManager.getAvailableAssets()**: åˆ©ç”¨å¯èƒ½ã‚¢ã‚»ãƒƒãƒˆä¸€è¦§
- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½**: å¤ã„ãƒ‡ãƒ¼ã‚¿ã¨ã®äº’æ›æ€§å•é¡Œè§£æ±º

### 3. å®Ÿè£…æ™‚ã®æ³¨æ„ç‚¹
- React Nativeã§ã¯å‹•çš„require()ã¯ä½¿ç”¨ä¸å¯
- ã‚¢ã‚»ãƒƒãƒˆã¯é™çš„å®šç¾©ãŒå¿…é ˆ
- WatermelonDBã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯JSON.stringify()ç¦æ­¢
- ãƒ•ã‚¡ã‚¤ãƒ«åã¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®æ•´åˆæ€§ç¶­æŒãŒé‡è¦

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™ï¼ˆç¾åœ¨ã®å®Ÿè£…ï¼‰

### 1. å®Ÿæ¸¬å€¤
- **ã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿**: é™çš„require()ã«ã‚ˆã‚Šå³åº§ã«åˆ©ç”¨å¯èƒ½
- **ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†**: 3æ®µéšã§ç¢ºå®Ÿãªã‚¢ã‚»ãƒƒãƒˆå–å¾—
- **äº’æ›æ€§**: æ—§ãƒ‡ãƒ¼ã‚¿ã¨ã®100%äº’æ›æ€§ç¶­æŒ
- **ãƒ‡ãƒãƒƒã‚°æ€§**: è©³ç´°ãªãƒ­ã‚°å‡ºåŠ›ã§å•é¡Œç‰¹å®šå¯èƒ½

---

## å¤‰æ›´å±¥æ­´

### 2025-08-25 æ›´æ–°
- **å®Ÿè£…çŠ¶æ³ã‚’åæ˜ **: ç†è«–çš„ãªè¨­è¨ˆã‹ã‚‰å®Ÿéš›ã®å®Ÿè£…çŠ¶æ³ã«æ›´æ–°
- **AssetManagerã‚¯ãƒ©ã‚¹è©³ç´°è¿½åŠ **: é™çš„ã‚¢ã‚»ãƒƒãƒˆç®¡ç†ã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆ¦ç•¥
- **React Nativeåˆ¶ç´„å¯¾å¿œ**: require()ã®é™çš„ä½¿ç”¨åˆ¶ç´„ã¨å¯¾å¿œæ–¹æ³•
- **ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°è¿½åŠ **: ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ–¹æ³•
- **JSONå¾ªç’°å‚ç…§å¯¾å¿œ**: WatermelonDBã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå®‰å…¨å‡¦ç†æ–¹æ³•
- **äº’æ›æ€§ãƒãƒƒãƒ”ãƒ³ã‚°**: æ—§ãƒ‡ãƒ¼ã‚¿ã¨ã®äº’æ›æ€§ç¶­æŒæ©Ÿèƒ½
- **ãƒ‡ãƒãƒƒã‚°æ”¯æ´æ©Ÿèƒ½**: AssetHelperã‚¯ãƒ©ã‚¹ã®è©³ç´°æ©Ÿèƒ½èª¬æ˜

*ğŸ“ Created: 2025-08-20 | ğŸ”„ Last Updated: 2025-08-25*