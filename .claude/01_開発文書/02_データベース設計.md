# Appcadia データベース設計

## データモデル概要

AppcadiaはWatermelonDBを使用したReact Native完全オフラインアプリケーションです。以下のエンティティで構成されます。

### エンティティ関係図

```
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│   Trainer   │      │    Goal     │      │   Stamp     │
│             │      │             │◆────○│             │
│ - id        │      │ - id        │      │ - id        │
│ - name      │      │ - title     │      │ - goalId    │
│ - type      │      │ - category  │      │ - date      │
│ - isSelected│      │ - isActive  │      │ - note      │
│ - avatarImg │      │ - createdAt │      │ - stampType │
└─────────────┘      │ - targetEnd │      └─────────────┘
                     └─────────────┘
                             │
                             ○
                             │
                     ┌─────────────┐      ┌─────────────┐
                     │ DailyAction │      │   Reward    │
                     │             │      │             │
                     │ - id        │      │ - id        │
                     │ - goalId    │      │ - trainerId │
                     │ - title     │      │ - type      │
                     │ - description│      │ - threshold │
                     │ - isRequired│      │ - isUnlocked│
                     └─────────────┘      │ - content   │
                                         └─────────────┘
```

## WatermelonDB エンティティ設計

### 1. **Trainer（トレーナー）**
```typescript
// src/database/models/Trainer.ts
export class TrainerModel extends Model {
  static table = 'trainers';
  
  @text('name') name!: string
  @text('type') type!: TrainerType        // "energetic", "calm", "strict", "gentle", "motivational"
  @field('is_selected') isSelected!: boolean
  @text('avatar_image_name') avatarImageName!: string
  @text('voice_prefix') voicePrefix!: string   // 音声ファイルのプレフィックス
  @text('description') description!: string
  @text('personality') personalityJson!: string // JSON文字列として保存
  @readonly @date('created_at') createdAt!: Date
  
  // リレーション
  @children('rewards') rewards: any
  
  // 計算プロパティ
  get personality(): TrainerPersonality {
    try {
      return JSON.parse(this.personalityJson || '{}');
    } catch (error) {
      return { catchphrase: '', supportiveWords: [] } as TrainerPersonality;
    }
  }
}
```

### 2. **Goal（目標）**
```typescript
// src/database/models/Goal.ts
export class GoalModel extends Model {
  static table = 'goals';
  
  @text('title') title!: string
  @text('category') category!: string      // 自由入力カテゴリ
  @text('target_description') targetDescription!: string
  @field('is_active') isActive!: boolean
  @readonly @date('created_at') createdAt!: Date
  @date('target_end_date') targetEndDate?: Date  // 任意の終了日
  @text('motivation') motivation!: string    // 目標設定時の動機
  @field('difficulty') difficulty!: number     // 1-5の難易度
  
  // 進捗関連
  @field('total_stamps') totalStamps!: number
  @field('current_streak') currentStreak!: number  // 連続達成日数
  @field('best_streak') bestStreak!: number     // 最高連続記録
  @date('last_stamp_date') lastStampDate?: Date
  
  // リレーション
  @children('daily_actions') dailyActions: any
  @children('stamps') stamps: any
}
```

### 3. **DailyAction（日次行動）**
```swift
@Entity
class DailyAction: NSManagedObject {
    @NSManaged var id: UUID
    @NSManaged var goalId: UUID
    @NSManaged var title: String
    @NSManaged var description: String
    @NSManaged var isRequired: Bool      // 必須行動かどうか
    @NSManaged var estimatedMinutes: Int16
    @NSManaged var reminderHour: Int16   // リマインダー時刻
    @NSManaged var reminderMinute: Int16
    @NSManaged var isReminderEnabled: Bool
    @NSManaged var sortOrder: Int16
    @NSManaged var createdAt: Date
    
    // リレーション
    @NSManaged var goal: Goal?
}
```

### 4. **Stamp（スタンプ）**
```typescript
// src/database/models/Stamp.ts
export class StampModel extends Model {
  static table = 'stamps';
  
  @text('goal_id') goalId!: string        // 関連目標ID
  @date('date') date!: Date               // スタンプ獲得日（日付のみ）
  @date('stamped_at') stampedAt!: Date    // スタンプした時刻
  @text('note') note!: string             // メモ（デフォルト空文字）
  @text('stamp_type') stampType!: string  // "daily", "study", "exercise"等
  @text('mood') mood!: string             // 気分記録 "happy", "excited", "neutral"等
  @field('difficulty') difficulty!: number // その日感じた難易度 (1-5)
  
  // リレーション
  @relation('goals', 'goal_id') goal!: Relation<GoalModel>
  
  // スタンプ追加メソッド
  async addStamp(): Promise<void> {
    await this.update(stamp => {
      stamp.totalStamps += 1;
      stamp.lastStampDate = new Date();
      // ストリーク計算ロジック
    });
  }
}
```

### 5. **Reward（報酬）**
```swift
@Entity
class Reward: NSManagedObject {
    @NSManaged var id: UUID
    @NSManaged var trainerId: UUID
    @NSManaged var type: String         // "voice", "illustration", "badge"
    @NSManaged var name: String
    @NSManaged var description: String
    @NSManaged var threshold: Int32     // 解放に必要なスタンプ数
    @NSManaged var isUnlocked: Bool
    @NSManaged var unlockedAt: Date?
    @NSManaged var contentFileName: String // ファイル名
    @NSManaged var rarity: String       // "common", "rare", "legendary"
    @NSManaged var category: String     // "encouragement", "celebration", "milestone"
    
    // リレーション
    @NSManaged var trainer: Trainer?
}
```

### 6. **AppSettings（アプリ設定）**
```swift
@Entity
class AppSettings: NSManagedObject {
    @NSManaged var id: UUID
    @NSManaged var selectedTrainerId: UUID?
    @NSManaged var isFirstLaunch: Bool
    @NSManaged var voiceVolume: Float
    @NSManaged var notificationEnabled: Bool
    @NSManaged var preferredNotificationTime: Date
    @NSManaged var themeMode: String    // "light", "dark", "auto"
    @NSManaged var language: String     // "ja", "en"
    @NSManaged var lastBackupDate: Date?
    @NSManaged var totalAppUsageDays: Int32
    @NSManaged var createdAt: Date
    @NSManaged var updatedAt: Date
}
```

## WatermelonDB スキーマ設計

### データベーススキーマ定義
```typescript
// src/database/schema.ts
import { appSchema, tableSchema } from '@nozbe/watermelondb';

export const schema = appSchema({
  version: 1,
  tables: [
    tableSchema({
      name: 'trainers',
      columns: [
        { name: 'name', type: 'string' },
        { name: 'type', type: 'string' },
        { name: 'is_selected', type: 'boolean' },
        { name: 'avatar_image_name', type: 'string' },
        { name: 'voice_prefix', type: 'string' },
        { name: 'description', type: 'string' },
        { name: 'personality', type: 'string' }, // JSON
        { name: 'created_at', type: 'number' }
      ]
    }),
    tableSchema({
      name: 'goals',
      columns: [
        { name: 'title', type: 'string' },
        { name: 'category', type: 'string' },
        { name: 'target_description', type: 'string' },
        { name: 'is_active', type: 'boolean' },
        { name: 'created_at', type: 'number' },
        { name: 'target_end_date', type: 'number', isOptional: true },
        { name: 'motivation', type: 'string' },
        { name: 'difficulty', type: 'number' },
        { name: 'total_stamps', type: 'number' },
        { name: 'current_streak', type: 'number' },
        { name: 'best_streak', type: 'number' },
        { name: 'last_stamp_date', type: 'number', isOptional: true }
      ]
    }),
    tableSchema({
      name: 'stamps',
      columns: [
        { name: 'goal_id', type: 'string', isIndexed: true },
        { name: 'date', type: 'number', isIndexed: true },
        { name: 'stamped_at', type: 'number' },
        { name: 'note', type: 'string' },
        { name: 'stamp_type', type: 'string' },
        { name: 'mood', type: 'string' },
        { name: 'difficulty', type: 'number' }
      ]
    })
  ]
});
```

### 1. **リレーションシップ**
```typescript
// Goal ←→ Stamp (一対多)
@children('stamps') stamps: Query<StampModel>

// Goal ←→ DailyAction (一対多)  
@children('daily_actions') dailyActions: Query<DailyActionModel>

// Trainer ←→ Reward (一対多)
@children('rewards') rewards: Query<RewardModel>
```

### 2. **初期データ定義**
```typescript
// src/database/database.ts - 初期トレーナーデータ
const seedTrainers = [
  {
    name: 'あかり',
    type: 'energetic',
    avatarImageName: 'akari.png',
    voicePrefix: 'akari',
    description: '元気いっぱいでサポートします！',
    personality: {
      catchphrase: '今日も一緒に頑張ろう！',
      supportiveWords: ['やったね！', 'すごいじゃない！', '頑張って！', 'きっとできる！']
    }
  },
  {
    name: 'いすず',
    type: 'calm',
    avatarImageName: 'isuzu.png',
    voicePrefix: 'isuzu',
    description: '落ち着いてサポートします',
    personality: {
      catchphrase: '一歩ずつ、着実に進みましょう',
      supportiveWords: ['素晴らしいですね', 'よく頑張りました', '順調ですね']
    }
  },
  // 他のトレーナーも同様に定義...
];
```

### 3. **WatermelonDBアダプター設定**
```typescript
// src/database/adapters/NativeAdapter.ts
import { NativeAdapter } from '@nozbe/watermelondb/adapters/NativeAdapter';
import { setUpDatabase } from '../database';

export const adapter = new NativeAdapter({
  dbName: 'AppcadiaDB',
  schema,
  migrations,
  jsi: Platform.OS === 'ios',
  onSetUpError: error => {
    console.error('Database setup error:', error);
  }
});
```

### 3. **Core Data設定**
```swift
// Persistent Container設定
lazy var persistentContainer: NSPersistentContainer = {
    let container = NSPersistentContainer(name: "Appcadia")
    
    // 暗号化設定
    let description = container.persistentStoreDescriptions.first
    description?.setOption(FileProtectionType.complete as NSObject, 
                          forKey: NSPersistentStoreFileProtectionKey)
    
    // バックグラウンド保存設定
    container.persistentStoreDescriptions.first?.setOption(true as NSNumber,
                          forKey: NSPersistentHistoryTrackingKey)
    
    container.loadPersistentStores { _, error in
        if let error = error {
            fatalError("Core Data error: \(error)")
        }
    }
    
    container.viewContext.automaticallyMergesChangesFromParent = true
    return container
}()
```

## データ操作パターン

### 1. **サービス層実装例**
```typescript
// src/services/StampService.ts
export class StampService {
  async createStamp(goalId: string, options?: {
    stampType?: string;
    mood?: string;
    difficulty?: number;
    note?: string;
  }): Promise<StampModel | null> {
    try {
      const database = getDatabase();
      if (!database) throw new Error('Database not available');

      let createdStamp: StampModel | null = null;
      
      await database.write(async () => {
        // スタンプを作成
        createdStamp = await database.get<StampModel>('stamps').create((stamp: any) => {
          stamp.goalId = goalId;
          stamp.date = new Date();
          stamp.stampedAt = new Date();
          stamp.stampType = options?.stampType || 'daily';
          stamp.mood = options?.mood || 'happy';
          stamp.difficulty = options?.difficulty || 3;
          stamp.note = options?.note || '';
        });

        // 関連する目標のスタンプ統計を更新
        const goal = await database.get<GoalModel>('goals').find(goalId);
        await goal.addStamp();
      });

      return createdStamp;
    } catch (error) {
      console.error('Failed to create stamp:', error);
      throw error;
    }
  }
  
  async getStampsByGoal(goalId: string): Promise<StampModel[]> {
    const database = getDatabase();
    if (!database) return [];

    const stamps = await database.get<StampModel>('stamps')
      .query()
      .fetch();

    return stamps.filter(stamp => stamp.goalId === goalId)
      .sort((a, b) => b.date.getTime() - a.date.getTime());
  }
}
```

### 2. **パフォーマンス最適化**
```swift
// バッチ操作
func batchUpdateStampCounts() async throws {
    let batchRequest = NSBatchUpdateRequest(entityName: "Goal")
    batchRequest.predicate = NSPredicate(format: "isActive == true")
    batchRequest.propertiesToUpdate = ["totalStamps": 0]
    
    try await context.perform {
        try context.execute(batchRequest)
    }
}

// 予期読み込み
func fetchGoalsWithRelations() async throws -> [Goal] {
    let request: NSFetchRequest<Goal> = Goal.fetchRequest()
    request.relationshipKeyPathsForPrefetching = ["stamps", "dailyActions"]
    
    return try await context.perform {
        try context.fetch(request)
    }
}
```

## データ移行戦略

### バージョン管理
```swift
// Core Data Model versions
// Version 1.0: 初期リリース
// Version 1.1: Reward entity追加
// Version 1.2: AppSettings entity追加

// 軽量マイグレーション設定
description?.shouldMigrateStoreAutomatically = true
description?.shouldInferMappingModelAutomatically = true
```